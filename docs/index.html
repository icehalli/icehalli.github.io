<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Clock</title>
    <style>
        body {
    background-color: black;
    color:white;
}
#clock {
    font-size: 175px;
    width: 900px;
    margin: 200px;
    margin-bottom: 0px;
    text-align: center;
    border-radius: 20px;
    border: 2px solid white;
}

#warn {
    font-size: 75px;
    width: 900px;
    margin: 200px;
    margin-bottom: 0px;
    margin-top: 15px;
    text-align: center;
    
    border-radius: 20px;
    border: 2px solid white;
    -webkit-box-shadow: 0px 0px 15px 3px rgba(255,255,255,1);
    -moz-box-shadow: 0px 0px 15px 3px rgba(255,255,255,1);
    box-shadow: 0px 0px 15px 3px rgba(255,255,255,1);
}

.active {
    /*normal*/
}
.bad{
    background-color: red;
}
.good{
    background-color: green;
}

.warning-active{
    border: 2px solid white;
    border-radius: 20px;
}

.overlay {
    background-color: black;
    position: absolute;
    top: 0;
    right: 0;
    width: 100px;
    height: 100vh;
    /**/
    -webkit-box-shadow: 0px 0px 15px 3px rgba(255,255,255,1);
    -moz-box-shadow: 0px 0px 15px 3px rgba(255,255,255,1);
    box-shadow: 0px 0px 15px 3px rgba(255,255,255,1);
    cursor: pointer;
}
.overlay-item {
    padding: 10px;
    margin: 10px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 18px;
}
.overlay-item-time {
    font-size: 18px;
    color: white;
    margin-right: 50px;
}
.overlay-item-name {
    font-size: 18px;
    color: white;
}
.overlay-item-selected {
    -webkit-box-shadow: 0px 0px 15px 3px rgba(255,255,255,1);
    -moz-box-shadow: 0px 0px 15px 3px rgba(255,255,255,1);
    box-shadow: 0px 0px 15px 3px rgba(255,255,255,1);
    color: white;
}

.idle {
    background-color: black;
}



.active2 {
    background-color: rgb(130, 226, 130);
    color: white;
    -webkit-box-shadow: 0px 0px 77px 0px rgba(223,180,240,1);
-moz-box-shadow: 0px 0px 77px 0px rgba(223,180,240,1);
box-shadow: 0px 0px 77px 0px rgba(223,180,240,1);
}

.warning {
    background-color:orange;
    color: white;
}
.danger {
    background-color:red;
    color: white;
}

.blinking-text {
    /* animation: blink 1s infinite;  */
    animation-name: blink;
    animation-duration: 1s;
    animation-iteration-count: 3;
}

@keyframes blink {
    0% {
        opacity: 1;
    }
    50% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}

    </style>
</head>

<body>
    <div id="clock" class="idle"></div>
    <div id="warn"></div>

    <script>
        Date.prototype.addHours = function(h) {
    this.setTime(this.getTime() + (h*60*60*1000));
    return this;
}


class DayPeriod {
    constructor(name, interval = 1000, start) {// start= null, '00:00', or date
        this.currentTime = new Date();
        if(start){
            if(typeof start === 'string'){
                this.currentTime = TimeHelpers.toTime(start);
            }
            else{
                this.currentTime = start;
            }
        }
        this.name = name;
        this.interval = interval;
        this.startInterval();
    }    

    startInterval() {
        if(!this.interval || this.interval < 1){
            return;
        }
        setInterval(() => {
            this.currentTime = new Date(this.currentTime.getTime() + 1000);
            // console.log(this.currentTime);
            // let time = this.getTime();
            // this.showTime(time);
        }, this.interval);        
    }
    
    getTime(){
        return this.currentTime;
    }
}

class Logger {
    static on = false;
    static Log(message){
        if(!this.on)
            return;
        console.log(JSON.parse(JSON.stringify(arguments)));
    }
}

class TimeHelpers {    
    static getTimeArr(decimalTime, hourMinSplitter = ':'){        
        let s = decimalTime + '';
        let sArr = s.split(hourMinSplitter);
        let h = parseInt(sArr[0]);
        let m = 0;
        if(sArr.length > 1){
            m = parseInt(sArr[1]);
        }
        return [h, m];
    }

    static toTime(h, hourMinSplitter = ':') {// h = '1:30'
        let timeArr = this.getTimeArr(h, hourMinSplitter);
        let time = new Date();
        time.setHours(timeArr[0]);
        time.setMinutes(timeArr[1]);
        time.setSeconds(0);
        time.setMilliseconds(0);
        return time;
    }
    
    static padPeriodWithZero(time){//1:00-2:00 => 01:00-02:00
        Logger.Log('padPeriodWithZero', time);
        let timeArr = time.split('-');
        return this.padTimeWithZero(timeArr[0]) + '-' + this.padTimeWithZero(timeArr[1]);
    }

    static padTimeWithZero(time){//1:00 => 01:00
        Logger.Log('padTimeWithZero', time);
        let timeArr = time.split(':');
        let h = timeArr[0];
        let m = timeArr[1];
        if(h.length === 1){
            h = '0' + h;
        }
        if(m.length === 1){
            m = '0' + m;
        }
        return h + ':' + m;
    }

    static timePeriodToFromToJson(timePeriod){
        let timeArr = timePeriod.split('-');
        let from = timeArr[0];
        let to = timeArr[1];
        return {
            from: from,
            to: to
        };
    }

    static timeToKey(time){
        return this.padTimeWithZero(time.getHours() + ':' + time.getMinutes());
    }   
}

class JsonFirstCollection {
    static items = [];
    static orderedKeys = [];
    static warnKeys = [];

    static add(item){
        if(this.overlapsToNextDay(item)){
            this.splitToNextDay(item);
        }
        else{
            this.items.push(item);
            let key = item.key;
            this.orderedKeys.push(key);
            this.orderedKeys.sort();
            if(item.warnTime)
                this.warnKeys.push(key);
            this.warnKeys.sort();
        }
    }

    static splitToNextDay(item){
        var ifrom = item.from;
        var ito = item.to;
        var key1 = TimeHelpers.timeToKey(ifrom) + '-23:59';
        var key2 = '00:00-' + TimeHelpers.timeToKey(ito);
        var period1 = new JsonFirst(key1, {
            name: item.name,
            warnTime: item.warnTime,
            className: item.className
        });
        var period2 = new JsonFirst(key2, {
            name: item.name,
            className: item.className
        });
        
        this.add(period1);
        this.add(period2);
    }
    
    static overlapsToNextDay(item){
        if(item.to < item.from){
            console.warn('overlapsToNextDay'.toUpperCase(), item);
            return true;
        }
        return false;
    }

    static processWarnings(){
        for(let i = 0; i < this.warnKeys.length; i++){
            let key = this.warnKeys[i];
            let item = this.getItem(key);
            this.splitToWarnings(key, item);
        }
    }

    static splitToWarnings(key, item) {
        let currentPositionInOrderedKeys = this.orderedKeys.indexOf(key);
        let previousKey = this.orderedKeys[currentPositionInOrderedKeys - 1];
        this.cropFromItem(previousKey, key);
    }

    static cropFromItem(previousKey, key){
        var cropFrom = this.getItem(previousKey);
        var warnItem = this.getItem(key);
        let warnTime = warnItem.warnTime;
        this.updateToTime(previousKey, this.getWarnTime(cropFrom.to, warnTime));

        //add zoon
        let zoonKey = cropFrom.to.getHours() + ':' + cropFrom.to.getMinutes() + '-' + warnItem.from.getHours() + ':' + warnItem.from.getMinutes();
        var zoonPeriod = new JsonFirst(zoonKey, {
            name: 'Zoon: ' + warnItem.name,
            className: warnItem.className
        }, 'warning');
        this.add(zoonPeriod);
    }

    static updateToTime(key, time){
        for(let i = 0; i < this.items.length; i++){
            if(this.items[i].key === key){
                this.items[i].to = time;
                return;
            }
        }
    }

    static getWarnTime(date, warnTime) {
        let time = new Date(date.getTime())
        let warnDateTime = TimeHelpers.toTime(warnTime);
        let warnHours = warnDateTime.getHours();
        let warnMinutes = warnDateTime.getMinutes();
        time.setHours(time.getHours() - warnHours);
        time.setMinutes(time.getMinutes() - warnMinutes);
        return time;
    }

    static getItem(key){
        return this.items.filter(x => x.key === key)[0];
    }

    static showPeriods(){
        for(let i = 0; i < this.orderedKeys.length; i++){
            let key = this.orderedKeys[i];
            let item = this.getItem(key);
            
        }
    }

    static getOrderedArray(asJsonOb = false){
        let result = [];
        let json = {};
        for(let i = 0; i < this.orderedKeys.length; i++){
            let key = this.orderedKeys[i];
            let item = this.getItem(key);
            result.push(item);
            json[item.getCalculatedKey()] = item.asJson();
        }
        if(asJsonOb)
            return json;
        return result;
    }
}

class JsonFirst {       
    constructorObject = { 
        "7:00-9:00" : {
            "name": "Morning",
            "warnTime": "0:30",
            "className": "good"
        }
    }
    constructor(key, ob, type = 'normal'){
        Logger.Log('JsonFirst', ob);
        this.constructorObject = ob;
        this.originalKey = key;
        this.className = ob.className;
        Logger.Log('originalKey', this.originalKey);
        this.key = TimeHelpers.padPeriodWithZero(this.originalKey);
        Logger.Log('key', this.key);
        this.name = ob.name;
        this.warnTime = ob.warnTime;

        this.from = TimeHelpers.toTime(this.key.split('-')[0]);
        this.to = TimeHelpers.toTime(this.key.split('-')[1]);
        this.originalItem = true;
        this.type = type;
        this.calculatedKey = null;
    }

    getCalculatedKey(forceRecalculate = false){
        if(!this.calculatedKey || forceRecalculate)
            this.calculatedKey = TimeHelpers.padPeriodWithZero(this.from.getHours() + ':' + this.from.getMinutes() + '-' + this.to.getHours() + ':' + this.to.getMinutes());
        return this.calculatedKey;
    }

    asJson(){
        return {
            name: this.name,
            from: this.from,
            to: this.to,
            type: this.type
        }
    }
}

class PeriodsOverlay {
    static overlayClosedWidth = '100px';
    static overlayOpenedWidth = '400px';
    static overlayInnerContent;
    static defaultOpen = true;
    static overlay;
    static addOverlay(data){
        this.overlay = document.createElement('div');
        this.overlay.id = 'overlay';
        this.overlay.onclick = () => {
            this.toggleOverlay(this.overlay.style.width !== this.overlayOpenedWidth);
        };
        this.overlay.classList.add('overlay');
        document.body.appendChild(this.overlay);
        this.fillContent(data, this.overlay);
        
        this.toggleOverlay(this.defaultOpen);
    }

    static toggleOverlay(open){
        if(open) {
            this.overlay.style.width = this.overlayOpenedWidth;
            this.overlayInnerContent.style.display = 'block';
        }
        else {
            this.overlay.style.width = this.overlayClosedWidth;
            this.overlayInnerContent.style.display = 'none';
        }
    }
    static fillContent(data, parent){
        this.overlayInnerContent = document.createElement('div');
        this.processInnerContentData(data);
        parent.appendChild(this.overlayInnerContent);
    }
    static processInnerContentData(data){
        for(let i = 0; i < data.length; i++){
            let key = data[i].getCalculatedKey();
            let div = document.createElement('div');
            let timeDiv = document.createElement('span');
            timeDiv.classList.add('overlay-item-time');
            timeDiv.innerHTML = key;
            let nameDiv = document.createElement('span');
            nameDiv.classList.add('overlay-item-name');
            nameDiv.innerHTML = data[i].name;
            div.id = 'overlay-item-' + key;
            div.appendChild(timeDiv);
            div.appendChild(nameDiv);
            // div.innerHTML = key+ '=>' + data[i].name;
            div.classList.add('overlay-item');
            this.overlayInnerContent.appendChild(div);
        }
    }
    static setSelectedItem(key){
        key = 'overlay-item-' + key;
        let items = document.getElementsByClassName('overlay-item');
        for(let i = 0; i < items.length; i++){
            items[i].classList.remove('overlay-item-selected');
        }
        let item = document.getElementById(key);
        if(item){
            item.classList.add('overlay-item-selected');
        }
    }
}


// default warnClass, activeClass, idleClass
var idleState = {
        "name": "normal-idle"
};
// var CLOCK = new DayPeriod('test', 5, '05:00');
var CLOCK = new DayPeriod('test');

let STATES = {
    "7:00-9:00" : {
        "name": "Morning",
        "warnTime": "0:30",
        "className": "good"
    },
    "10:30-16:00" : {
        "name": "Day",
        "warnTime": "0:30",
    },
    "16:00-18:00" : {
        "name": "Late Afternoon",
        "warnTime": "0:30",
    }, 
    "22:00-01:00" : {
        "name": "Silent",
        "warnTime": "0:30",
        "warnClass": "danger",
    },
    "18:00-20:00" : {
        "name": "Dinner time"
    },
    "20:00-22:00" : {
        "name": "Relax",
        "warnTime": "0:10",
    },   
    "1:00-6:00" : {
        "name": "Total silence",
        "warnTime": "0:30",
        "className": "bad"
    }
}

function normalizePeriods(){
    Logger.Log('STATES', STATES);
    first(STATES);
}
setTimeout(() => {    
    normalizePeriods();
}, 1);

function first(states){
    let keys = Object.keys(states);
    Logger.Log('first:keys', keys);
    keys.sort();
    let newShortColorStates = {};
    for(let i = 0; i < keys.length; i++){
        Logger.Log('first:states[keys[i]', states[keys[i]]);
        let n = new JsonFirst(keys[i], states[keys[i]]);
        JsonFirstCollection.add(n);
    }    
    JsonFirstCollection.processWarnings();
    console.log('JsonFirstCollection', JsonFirstCollection.orderedKeys);
    console.log('JsonFirstCollection:items', JsonFirstCollection.items);
    console.log('JsonFirstCollection:warnKeys', JsonFirstCollection.warnKeys);
    JsonFirstCollection.showPeriods();
    console.log('OBJECT', JsonFirstCollection.getOrderedArray());
    console.log('JSON', JsonFirstCollection.getOrderedArray(true));
    PeriodsOverlay.addOverlay(JsonFirstCollection.getOrderedArray());

    startClock();
}

function addOverlay(){

}

function getWarnEl() {
    return document.getElementById("warn");
}
function getClockEl() {
    return document.getElementById("clock");
}

let ACTIVESTATE = null;
let ACTIVESTATE_Class = null;
function inState(time, state){
    if(time >= state.from && time <= state.to){
        return true;
    }
    return false;
}
function showState(state){
    // console.log('ACTIVESTATE', ACTIVESTATE);
    // console.log('showState', state.getCalculatedKey());
    if(ACTIVESTATE === state.getCalculatedKey()){
        return;
    }
    ACTIVESTATE = state.getCalculatedKey();
    PeriodsOverlay.setSelectedItem(ACTIVESTATE);
    console.log(state.type, state.getCalculatedKey());
    let clock = getClockEl();
    let warn = getWarnEl();
    if(state.type === 'warning'){
        warn.innerHTML = state.name;
        warn.classList.remove(ACTIVESTATE_Class); 
        ACTIVESTATE_Class = state.className ?? 'warning';
        warn.classList.add(ACTIVESTATE_Class);   
        warn.classList.add("blinking-text");
        setTimeout(() => {
            warn.classList.remove("blinking-text");            
        }, 3000);
    }
    else{
        warn.innerHTML = state.name;
        warn.classList.remove(ACTIVESTATE_Class); 
        ACTIVESTATE_Class = state.className ?? 'active';
        warn.classList.add(ACTIVESTATE_Class);   
        warn.classList.add("blinking-text");
        setTimeout(() => {
            warn.classList.remove("blinking-text");            
        }, 3000);
    }
    if(ACTIVESTATE_Class === 'bad'){
        document.body.classList.add("blinking-text");
        document.body.classList.add("bad");
        setTimeout(() => {
            document.body.classList.remove("blinking-text");         
            document.body.classList.remove("bad");   
        }, 3000);
    }
}

function processStates(time) {
    let ss = JsonFirstCollection.getOrderedArray();
    let keys = Object.keys(ss);
    for (let i = 0; i < keys.length; i++) {
        if(inState(time, ss[keys[i]])){
            showState(ss[keys[i]]);
            break;
        }        
    }
}

function startInterval() {
    setInterval(function(){
        let time = new Date().addHours(5.5);
        showTime(CLOCK.getTime());
    }, 1);        
}

function setTime(time){
    
    // console.log(time);
    if(!time)
        time = new Date();
    let useAmPm = false;
    let showSeconds = false;
    let hour =
        time.getHours();
    let min =
        time.getMinutes();
    let sec =
        time.getSeconds();
    am_pm = "AM";

    if(useAmPm){
        if (hour >= 12) {
            if (hour > 12)
                hour -= 12;
            am_pm = "PM";
        } else if (hour == 0) {
            hr = 12;
            am_pm = "AM";
        }
    }
    else
        am_pm = "";

    hour =
        hour < 10
            ? "0" + hour
            : hour;
    min =
        min < 10
            ? "0" + min
            : min;
    sec =
        sec < 10
            ? "0" + sec
            : sec;

    let secText = ":" + sec;
    if(!showSeconds){
        secText = "";
    }

    let currentTime =
        hour +
        ":" +
        min +
        secText +
        " " +
        am_pm;

    document.getElementById(
        "clock"
    ).innerHTML =
        currentTime;
}
function showTime(time) {
    setTime(time);
    processStates(time);
}

function startClock() {
    showTime(CLOCK.getTime());
    startInterval();
}

    </script>
</body>

</html>
